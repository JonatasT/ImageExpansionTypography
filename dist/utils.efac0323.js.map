{"version":3,"sources":["node_modules/ev-emitter/ev-emitter.js","node_modules/imagesloaded/imagesloaded.js","js/presentes/utils.js"],"names":["imagesLoaded","require","preloadImages","exports","selector","arguments","length","undefined","Promise","resolve","document","querySelectorAll","background","calcWinsize","width","window","innerWidth","height","innerHeight","getScrollValues","supportPageOffset","pageXOffset","isCSS1Compat","compatMode","x","documentElement","scrollLeft","body","y","pageYOffset","scrollTop","wrapLines","elems","wrapType","wrapClass","forEach","char","wrapEl","createElement","classList","parentNode","appendChild","adjustedBoundingRect","el","rect","getBoundingClientRect","style","getComputedStyle","tx","transform","sx","sy","dx","dy","startsWith","ta","slice","split","to","transformOrigin","parseFloat","indexOf","w","offsetWidth","h","offsetHeight","top","right","bottom","left","addEventListener","scrollY","headerNav","position","headerNavContainer","add","remove"],"mappings":"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ACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"utils.efac0323.js","sourceRoot":"..","sourcesContent":["/**\n * EvEmitter v2.1.1\n * Lil' event emitter\n * MIT License\n */\n\n( function( global, factory ) {\n  // universal module definition\n  if ( typeof module == 'object' && module.exports ) {\n    // CommonJS - Browserify, Webpack\n    module.exports = factory();\n  } else {\n    // Browser globals\n    global.EvEmitter = factory();\n  }\n\n}( typeof window != 'undefined' ? window : this, function() {\n\nfunction EvEmitter() {}\n\nlet proto = EvEmitter.prototype;\n\nproto.on = function( eventName, listener ) {\n  if ( !eventName || !listener ) return this;\n\n  // set events hash\n  let events = this._events = this._events || {};\n  // set listeners array\n  let listeners = events[ eventName ] = events[ eventName ] || [];\n  // only add once\n  if ( !listeners.includes( listener ) ) {\n    listeners.push( listener );\n  }\n\n  return this;\n};\n\nproto.once = function( eventName, listener ) {\n  if ( !eventName || !listener ) return this;\n\n  // add event\n  this.on( eventName, listener );\n  // set once flag\n  // set onceEvents hash\n  let onceEvents = this._onceEvents = this._onceEvents || {};\n  // set onceListeners object\n  let onceListeners = onceEvents[ eventName ] = onceEvents[ eventName ] || {};\n  // set flag\n  onceListeners[ listener ] = true;\n\n  return this;\n};\n\nproto.off = function( eventName, listener ) {\n  let listeners = this._events && this._events[ eventName ];\n  if ( !listeners || !listeners.length ) return this;\n\n  let index = listeners.indexOf( listener );\n  if ( index != -1 ) {\n    listeners.splice( index, 1 );\n  }\n\n  return this;\n};\n\nproto.emitEvent = function( eventName, args ) {\n  let listeners = this._events && this._events[ eventName ];\n  if ( !listeners || !listeners.length ) return this;\n\n  // copy over to avoid interference if .off() in listener\n  listeners = listeners.slice( 0 );\n  args = args || [];\n  // once stuff\n  let onceListeners = this._onceEvents && this._onceEvents[ eventName ];\n\n  for ( let listener of listeners ) {\n    let isOnce = onceListeners && onceListeners[ listener ];\n    if ( isOnce ) {\n      // remove listener\n      // remove before trigger to prevent recursion\n      this.off( eventName, listener );\n      // unset once flag\n      delete onceListeners[ listener ];\n    }\n    // trigger listener\n    listener.apply( this, args );\n  }\n\n  return this;\n};\n\nproto.allOff = function() {\n  delete this._events;\n  delete this._onceEvents;\n  return this;\n};\n\nreturn EvEmitter;\n\n} ) );\n","/*!\n * imagesLoaded v5.0.0\n * JavaScript is all like \"You images are done yet or what?\"\n * MIT License\n */\n\n( function( window, factory ) {\n  // universal module definition\n  if ( typeof module == 'object' && module.exports ) {\n    // CommonJS\n    module.exports = factory( window, require('ev-emitter') );\n  } else {\n    // browser global\n    window.imagesLoaded = factory( window, window.EvEmitter );\n  }\n\n} )( typeof window !== 'undefined' ? window : this,\n    function factory( window, EvEmitter ) {\n\nlet $ = window.jQuery;\nlet console = window.console;\n\n// -------------------------- helpers -------------------------- //\n\n// turn element or nodeList into an array\nfunction makeArray( obj ) {\n  // use object if already an array\n  if ( Array.isArray( obj ) ) return obj;\n\n  let isArrayLike = typeof obj == 'object' && typeof obj.length == 'number';\n  // convert nodeList to array\n  if ( isArrayLike ) return [ ...obj ];\n\n  // array of single index\n  return [ obj ];\n}\n\n// -------------------------- imagesLoaded -------------------------- //\n\n/**\n * @param {[Array, Element, NodeList, String]} elem\n * @param {[Object, Function]} options - if function, use as callback\n * @param {Function} onAlways - callback function\n * @returns {ImagesLoaded}\n */\nfunction ImagesLoaded( elem, options, onAlways ) {\n  // coerce ImagesLoaded() without new, to be new ImagesLoaded()\n  if ( !( this instanceof ImagesLoaded ) ) {\n    return new ImagesLoaded( elem, options, onAlways );\n  }\n  // use elem as selector string\n  let queryElem = elem;\n  if ( typeof elem == 'string' ) {\n    queryElem = document.querySelectorAll( elem );\n  }\n  // bail if bad element\n  if ( !queryElem ) {\n    console.error(`Bad element for imagesLoaded ${queryElem || elem}`);\n    return;\n  }\n\n  this.elements = makeArray( queryElem );\n  this.options = {};\n  // shift arguments if no options set\n  if ( typeof options == 'function' ) {\n    onAlways = options;\n  } else {\n    Object.assign( this.options, options );\n  }\n\n  if ( onAlways ) this.on( 'always', onAlways );\n\n  this.getImages();\n  // add jQuery Deferred object\n  if ( $ ) this.jqDeferred = new $.Deferred();\n\n  // HACK check async to allow time to bind listeners\n  setTimeout( this.check.bind( this ) );\n}\n\nImagesLoaded.prototype = Object.create( EvEmitter.prototype );\n\nImagesLoaded.prototype.getImages = function() {\n  this.images = [];\n\n  // filter & find items if we have an item selector\n  this.elements.forEach( this.addElementImages, this );\n};\n\nconst elementNodeTypes = [ 1, 9, 11 ];\n\n/**\n * @param {Node} elem\n */\nImagesLoaded.prototype.addElementImages = function( elem ) {\n  // filter siblings\n  if ( elem.nodeName === 'IMG' ) {\n    this.addImage( elem );\n  }\n  // get background image on element\n  if ( this.options.background === true ) {\n    this.addElementBackgroundImages( elem );\n  }\n\n  // find children\n  // no non-element nodes, #143\n  let { nodeType } = elem;\n  if ( !nodeType || !elementNodeTypes.includes( nodeType ) ) return;\n\n  let childImgs = elem.querySelectorAll('img');\n  // concat childElems to filterFound array\n  for ( let img of childImgs ) {\n    this.addImage( img );\n  }\n\n  // get child background images\n  if ( typeof this.options.background == 'string' ) {\n    let children = elem.querySelectorAll( this.options.background );\n    for ( let child of children ) {\n      this.addElementBackgroundImages( child );\n    }\n  }\n};\n\nconst reURL = /url\\((['\"])?(.*?)\\1\\)/gi;\n\nImagesLoaded.prototype.addElementBackgroundImages = function( elem ) {\n  let style = getComputedStyle( elem );\n  // Firefox returns null if in a hidden iframe https://bugzil.la/548397\n  if ( !style ) return;\n\n  // get url inside url(\"...\")\n  let matches = reURL.exec( style.backgroundImage );\n  while ( matches !== null ) {\n    let url = matches && matches[2];\n    if ( url ) {\n      this.addBackground( url, elem );\n    }\n    matches = reURL.exec( style.backgroundImage );\n  }\n};\n\n/**\n * @param {Image} img\n */\nImagesLoaded.prototype.addImage = function( img ) {\n  let loadingImage = new LoadingImage( img );\n  this.images.push( loadingImage );\n};\n\nImagesLoaded.prototype.addBackground = function( url, elem ) {\n  let background = new Background( url, elem );\n  this.images.push( background );\n};\n\nImagesLoaded.prototype.check = function() {\n  this.progressedCount = 0;\n  this.hasAnyBroken = false;\n  // complete if no images\n  if ( !this.images.length ) {\n    this.complete();\n    return;\n  }\n\n  /* eslint-disable-next-line func-style */\n  let onProgress = ( image, elem, message ) => {\n    // HACK - Chrome triggers event before object properties have changed. #83\n    setTimeout( () => {\n      this.progress( image, elem, message );\n    } );\n  };\n\n  this.images.forEach( function( loadingImage ) {\n    loadingImage.once( 'progress', onProgress );\n    loadingImage.check();\n  } );\n};\n\nImagesLoaded.prototype.progress = function( image, elem, message ) {\n  this.progressedCount++;\n  this.hasAnyBroken = this.hasAnyBroken || !image.isLoaded;\n  // progress event\n  this.emitEvent( 'progress', [ this, image, elem ] );\n  if ( this.jqDeferred && this.jqDeferred.notify ) {\n    this.jqDeferred.notify( this, image );\n  }\n  // check if completed\n  if ( this.progressedCount === this.images.length ) {\n    this.complete();\n  }\n\n  if ( this.options.debug && console ) {\n    console.log( `progress: ${message}`, image, elem );\n  }\n};\n\nImagesLoaded.prototype.complete = function() {\n  let eventName = this.hasAnyBroken ? 'fail' : 'done';\n  this.isComplete = true;\n  this.emitEvent( eventName, [ this ] );\n  this.emitEvent( 'always', [ this ] );\n  if ( this.jqDeferred ) {\n    let jqMethod = this.hasAnyBroken ? 'reject' : 'resolve';\n    this.jqDeferred[ jqMethod ]( this );\n  }\n};\n\n// --------------------------  -------------------------- //\n\nfunction LoadingImage( img ) {\n  this.img = img;\n}\n\nLoadingImage.prototype = Object.create( EvEmitter.prototype );\n\nLoadingImage.prototype.check = function() {\n  // If complete is true and browser supports natural sizes,\n  // try to check for image status manually.\n  let isComplete = this.getIsImageComplete();\n  if ( isComplete ) {\n    // report based on naturalWidth\n    this.confirm( this.img.naturalWidth !== 0, 'naturalWidth' );\n    return;\n  }\n\n  // If none of the checks above matched, simulate loading on detached element.\n  this.proxyImage = new Image();\n  // add crossOrigin attribute. #204\n  if ( this.img.crossOrigin ) {\n    this.proxyImage.crossOrigin = this.img.crossOrigin;\n  }\n  this.proxyImage.addEventListener( 'load', this );\n  this.proxyImage.addEventListener( 'error', this );\n  // bind to image as well for Firefox. #191\n  this.img.addEventListener( 'load', this );\n  this.img.addEventListener( 'error', this );\n  this.proxyImage.src = this.img.currentSrc || this.img.src;\n};\n\nLoadingImage.prototype.getIsImageComplete = function() {\n  // check for non-zero, non-undefined naturalWidth\n  // fixes Safari+InfiniteScroll+Masonry bug infinite-scroll#671\n  return this.img.complete && this.img.naturalWidth;\n};\n\nLoadingImage.prototype.confirm = function( isLoaded, message ) {\n  this.isLoaded = isLoaded;\n  let { parentNode } = this.img;\n  // emit progress with parent <picture> or self <img>\n  let elem = parentNode.nodeName === 'PICTURE' ? parentNode : this.img;\n  this.emitEvent( 'progress', [ this, elem, message ] );\n};\n\n// ----- events ----- //\n\n// trigger specified handler for event type\nLoadingImage.prototype.handleEvent = function( event ) {\n  let method = 'on' + event.type;\n  if ( this[ method ] ) {\n    this[ method ]( event );\n  }\n};\n\nLoadingImage.prototype.onload = function() {\n  this.confirm( true, 'onload' );\n  this.unbindEvents();\n};\n\nLoadingImage.prototype.onerror = function() {\n  this.confirm( false, 'onerror' );\n  this.unbindEvents();\n};\n\nLoadingImage.prototype.unbindEvents = function() {\n  this.proxyImage.removeEventListener( 'load', this );\n  this.proxyImage.removeEventListener( 'error', this );\n  this.img.removeEventListener( 'load', this );\n  this.img.removeEventListener( 'error', this );\n};\n\n// -------------------------- Background -------------------------- //\n\nfunction Background( url, element ) {\n  this.url = url;\n  this.element = element;\n  this.img = new Image();\n}\n\n// inherit LoadingImage prototype\nBackground.prototype = Object.create( LoadingImage.prototype );\n\nBackground.prototype.check = function() {\n  this.img.addEventListener( 'load', this );\n  this.img.addEventListener( 'error', this );\n  this.img.src = this.url;\n  // check if image is already complete\n  let isComplete = this.getIsImageComplete();\n  if ( isComplete ) {\n    this.confirm( this.img.naturalWidth !== 0, 'naturalWidth' );\n    this.unbindEvents();\n  }\n};\n\nBackground.prototype.unbindEvents = function() {\n  this.img.removeEventListener( 'load', this );\n  this.img.removeEventListener( 'error', this );\n};\n\nBackground.prototype.confirm = function( isLoaded, message ) {\n  this.isLoaded = isLoaded;\n  this.emitEvent( 'progress', [ this, this.element, message ] );\n};\n\n// -------------------------- jQuery -------------------------- //\n\nImagesLoaded.makeJQueryPlugin = function( jQuery ) {\n  jQuery = jQuery || window.jQuery;\n  if ( !jQuery ) return;\n\n  // set local variable\n  $ = jQuery;\n  // $().imagesLoaded()\n  $.fn.imagesLoaded = function( options, onAlways ) {\n    let instance = new ImagesLoaded( this, options, onAlways );\n    return instance.jqDeferred.promise( $( this ) );\n  };\n};\n// try making plugin\nImagesLoaded.makeJQueryPlugin();\n\n// --------------------------  -------------------------- //\n\nreturn ImagesLoaded;\n\n} );\n","const imagesLoaded = require('imagesloaded');\n\n// Preload images\nconst preloadImages = (selector = 'img') => {\n    return new Promise((resolve) => {\n        imagesLoaded(document.querySelectorAll(selector), {background: true}, resolve);\n    });\n};\n\nconst calcWinsize = () => {\n    return { width: window.innerWidth, height: window.innerHeight };\n};\n\nconst getScrollValues = () => {\n    const supportPageOffset = window.pageXOffset !== undefined;\n    const isCSS1Compat = ((document.compatMode || \"\") === \"CSS1Compat\");\n    const x = supportPageOffset ? window.pageXOffset : isCSS1Compat ? document.documentElement.scrollLeft : document.body.scrollLeft;\n    const y = supportPageOffset ? window.pageYOffset : isCSS1Compat ? document.documentElement.scrollTop : document.body.scrollTop;\n    return {x,y};\n}\n\n// wrap each element of an array\n// elems - the array of elements to wrap\n// wrapType - type of wrapper ('div', 'span' etc)\n// wrapClass - wrapper class(s) \nconst wrapLines = (elems, wrapType, wrapClass) => {\n    elems.forEach(char => {\n        // add a wrap for every char (overflow hidden)\n        const wrapEl = document.createElement(wrapType);\n        wrapEl.classList = wrapClass;\n        char.parentNode.appendChild(wrapEl);\n        wrapEl.appendChild(char);\n    });\n}\n\nconst adjustedBoundingRect = el => {\n    var rect = el.getBoundingClientRect();\n    var style = getComputedStyle(el);\n    var tx = style.transform;\n  \n    if (tx) {\n      var sx, sy, dx, dy;\n      if (tx.startsWith('matrix3d(')) {\n        var ta = tx.slice(9,-1).split(/, /);\n        sx = +ta[0];\n        sy = +ta[5];\n        dx = +ta[12];\n        dy = +ta[13];\n      } else if (tx.startsWith('matrix(')) {\n        var ta = tx.slice(7,-1).split(/, /);\n        sx = +ta[0];\n        sy = +ta[3];\n        dx = +ta[4];\n        dy = +ta[5];\n      } else {\n        return rect;\n      }\n  \n      var to = style.transformOrigin;\n      var x = rect.x - dx - (1 - sx) * parseFloat(to);\n      var y = rect.y - dy - (1 - sy) * parseFloat(to.slice(to.indexOf(' ') + 1));\n      var w = sx ? rect.width / sx : el.offsetWidth;\n      var h = sy ? rect.height / sy : el.offsetHeight;\n      return {\n        x: x, y: y, width: w, height: h, top: y, right: x + w, bottom: y + h, left: x\n      };\n    } else {\n      return rect;\n    }\n}\n\nexport { \n    preloadImages,\n    calcWinsize,\n    getScrollValues,\n    wrapLines,\n    adjustedBoundingRect\n};\n\n\nwindow.addEventListener('scroll', () => {\n  if(window.scrollY > 0) {\n    headerNav.style.position = 'sticky';\n    headerNavContainer.classList.add('frame__nav--header--sticky');\n  } else {\n    headerNav.style.position = 'relative'; // or whatever the default position is\n    headerNavContainer.classList.remove('frame__nav--header--sticky');\n  }\n});"]}